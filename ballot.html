<html>
  <head>
    <title>SmartVote Ballot</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.6.1/dist/web3.min.js"></script>
    <script src="ballot_abi.js"></script>
  </head>
  <body>
    <h1>Grant Voting Rights</h1>
    <div>
      <!-- Text area for inputting voters' addresses -->
      <textarea id="votersList" placeholder="Enter addresses separated by commas"></textarea><br><br>
      <button onclick="grantVotingRights()">Grant Voting Rights</button>
    </div>
    
    <div>
      <h3>Revoke Voting Rights</h3>
      <!-- Text area for inputting voters' addresses -->
      <textarea id="revokeVotersList" placeholder="Enter addresses separated by commas"></textarea><br><br>
      <button onclick="revokeVotingRights()">Revoke Voting Rights</button>
    </div>
    
    <h1>Declare Winner</h1>
    <div>
      <button onclick="getWinnerName()">Get Winner Name</button>
    </div>
    
    <h1>Voting Time Remaining</h1>
    <div>
      <p id="remainingTime">Click to load remaining time...</p>
      <button onclick="updateRemainingTime()">Check Remaining Time</button>
    </div>

    <script>
      const web3 = new Web3(Web3.givenProvider || "http://localhost:7545"); // Connect to Ganache

      const contractAddress = "0xC5798141Ae3341DdC17AdfA7a69B6D51e63B6ee2"; // Replace with your deployed contract address
      const ballotContract = new web3.eth.Contract(ballotABI, contractAddress);
      
      // Function to grant voting rights (called by chairperson)
      async function grantVotingRights() {
        try {
          const accounts = await web3.eth.requestAccounts();
          const connectedAddress = accounts[0];  // Get the connected account
          
          // Check if the connected account is the chairperson
          const chairpersonAddress = await ballotContract.methods.chairperson().call();

          if (connectedAddress !== chairpersonAddress) {
            alert("Only the chairperson can grant voting rights.");
            return;
          }

          // Get voter addresses from the textarea input field
          const voterAddresses = document.getElementById('votersList').value.split(',').map(address => address.trim());

          if (voterAddresses.length === 0 || voterAddresses.some(address => !web3.utils.isAddress(address))) {
            alert("Please enter valid Ethereum addresses separated by commas.");
            return;
          }

          await ballotContract.methods.giveRightsToMultipleVoters(voterAddresses).send({ from: chairpersonAddress });
          alert("Voting rights granted!");
        } catch (error) {
          console.error("Error granting voting rights: ", error);
          alert("There was an error while granting voting rights.");
        }
      }
      
      async function revokeVotingRights() {
        try {
          const accounts = await web3.eth.requestAccounts();
          const connectedAddress = accounts[0];  // Get the connected account
          
          // Check if the connected account is the chairperson
          const chairpersonAddress = await ballotContract.methods.chairperson().call();

          if (connectedAddress !== chairpersonAddress) {
            alert("Only the chairperson can revoke voting rights.");
            return;
          }

          // Get voter addresses from the textarea input field
          const votersAddresses = document.getElementById('revokeVotersList').value.split(',').map(address => address.trim());

          if (votersAddresses.length === 0 || votersAddresses.some(address => !web3.utils.isAddress(address))) {
            alert("Please enter valid Ethereum addresses separated by commas.");
            return;
          }

          await ballotContract.methods.revokeVotingRights(votersAddresses).send({ from: chairpersonAddress });
          alert("Voting rights revoked!");
        } catch (error) {
          console.error("Error revoking voting rights: ", error);
          alert("There was an error while revoking voting rights.");
        }
      }
      
      async function updateRemainingTime() {
        try {
          const remainingTimeInSeconds = await ballotContract.methods.remainingTime().call();
          
          // Calculate hours, minutes, and seconds
          const hours = Math.floor(remainingTimeInSeconds / 3600);
          const minutes = Math.floor((remainingTimeInSeconds % 3600) / 60);
          const seconds = remainingTimeInSeconds % 60;
          
          // Display the remaining time in the format: "X hours, Y minutes, Z seconds"
          const timeString = `${hours} hours, ${minutes} minutes, ${seconds} seconds`;
          
          document.getElementById("remainingTime").innerText = "Time remaining: " + timeString;
        } catch (error) {
          console.error("Error fetching remaining time: ", error);
          alert("There was an error fetching the remaining time.");
        }
      }

      // Function to get the winner's name
      async function getWinnerName() {
        try {
          const accounts = await web3.eth.requestAccounts();
          const connectedAddress = accounts[0];  // Get the connected account
          
          // Check if the connected account is the chairperson
          const chairpersonAddress = await ballotContract.methods.chairperson().call();

          if (connectedAddress !== chairpersonAddress) {
            alert("Only the chairperson can get the winner name.");
            return;
          }

          const winner = await ballotContract.methods.winnerName().call(); // Use call() for view function
          alert("The winner is: " + web3.utils.hexToUtf8(winner)); // Convert bytes32 to string
        } catch (error) {
          console.error("Error fetching winner: ", error);
          alert("There was an error while fetching the winner.");
        }
      }
    </script>
  </body>
</html>
